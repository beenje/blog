<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tchut-Tchut Blog (Posts about bot)</title><link>http://beenje.github.io/blog/</link><description></description><atom:link href="http://beenje.github.io/blog/categories/bot.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2021 &lt;a href="mailto:beenje@gmail.com"&gt;Benjamin Bertrand&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Wed, 06 Jan 2021 08:21:41 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Building a GitLab bot using gidgetlab, Starlette and HTTPX</title><link>http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-starlette-and-httpx/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;I previously described how to create a &lt;a class="reference external" href="http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-and-aiohttp"&gt;GitLab bot using gidgetlab and aiohttp&lt;/a&gt;.
I recently read and became curious about &lt;a class="reference external" href="https://fastapi.tiangolo.com"&gt;FastAPI&lt;/a&gt; and &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt;. The latter seemed
like a good fit for a GitLab bot and a nice way to experiment with it for me.&lt;/p&gt;
&lt;p&gt;If you haven't heard about &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt;, I recommend starting with my &lt;a class="reference external" href="http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-and-aiohttp"&gt;previous post&lt;/a&gt;.
I won't explain again how to create an access token or configure a webhook.&lt;/p&gt;
&lt;p&gt;To build a bot, we need both an HTTP client and server. &lt;a class="reference external" href="https://docs.aiohttp.org/en/stable/"&gt;aiohttp&lt;/a&gt; provides both.
&lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; is a lightweight &lt;a class="reference external" href="https://asgi.readthedocs.io/en/latest/"&gt;ASGI&lt;/a&gt; framework. It doesn't include an HTTP client.
&lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; supports several HTTP clients. I recently added &lt;a class="reference external" href="https://www.python-httpx.org"&gt;HTTPX&lt;/a&gt;, thanks to &lt;a class="reference external" href="https://gidgethub.readthedocs.io/en/latest/"&gt;gidgethub&lt;/a&gt; once again.
It's described as the next-generation HTTP client for Python and will play well with &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's start by a small example on how to use &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; with &lt;a class="reference external" href="https://www.python-httpx.org"&gt;HTTPX&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="using-gidgetlab-with-httpx-on-the-command-line"&gt;
&lt;h2&gt;Using gidgetlab with HTTPX on the command line&lt;/h2&gt;
&lt;div class="section" id="install-gidgetlab-and-httpx"&gt;
&lt;h3&gt;Install gidgetlab and httpx&lt;/h3&gt;
&lt;p&gt;Install &lt;code class="docutils literal"&gt;gidgetlab&lt;/code&gt; and &lt;code class="docutils literal"&gt;httpx&lt;/code&gt; if you have not already. Using a virtual environment
is recommended.&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3 -m pip install gidgetlab[httpx]&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="create-an-issue"&gt;
&lt;h3&gt;Create an issue&lt;/h3&gt;
&lt;p&gt;We'll use the same example as in the &lt;a class="reference external" href="http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-and-aiohttp"&gt;previous post&lt;/a&gt; but replace &lt;a class="reference external" href="https://docs.aiohttp.org/en/stable/"&gt;aiohttp&lt;/a&gt; with &lt;a class="reference external" href="https://www.python-httpx.org"&gt;httpx&lt;/a&gt;.
Copy the following into the file &lt;code class="docutils literal"&gt;create_issue.py&lt;/code&gt; using your favorite editor:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import asyncio
import os
import httpx
import gidgetlab.httpx


async def main():
    async with httpx.AsyncClient() as client:
        gl = gidgetlab.httpx.GitLabAPI(
            client, "gidgetlab", access_token=os.environ.get("GL_ACCESS_TOKEN")
        )
        await gl.post(
            "/projects/beenje%2Fstrange-relationship/issues",
            data={
                "title": "We got a problem",
                "description": "You should use HTTPX!",
            })


asyncio.run(main())&lt;/pre&gt;
&lt;p&gt;If you check the example with &lt;a class="reference external" href="https://docs.aiohttp.org/en/stable/"&gt;aiohttp&lt;/a&gt; from my previous post, you can see it's pretty similar.&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ diff -u aiohttp_create_issue.py create_issue.py
--- aiohttp_create_issue.py 2020-05-31 21:31:52.000000000 +0200
+++ create_issue.py 2020-05-31 21:26:19.000000000 +0200
@@ -1,12 +1,14 @@
 import asyncio
 import os
-import aiohttp
-from gidgetlab.aiohttp import GitLabAPI
+import httpx
+import gidgetlab.httpx


 async def main():
-    async with aiohttp.ClientSession() as session:
-        gl = GitLabAPI(session, "beenje", access_token=os.getenv("GL_ACCESS_TOKEN"))
+    async with httpx.AsyncClient() as client:
+        gl = gidgetlab.httpx.GitLabAPI(
+            client, "gidgetlab", access_token=os.environ.get("GL_ACCESS_TOKEN")
+        )
         await gl.post(
             "/projects/beenje%2Fstrange-relationship/issues",
             data={
@@ -15,5 +17,4 @@
             })


-loop = asyncio.get_event_loop()
-loop.run_until_complete(main()
+asyncio.run(main())&lt;/pre&gt;
&lt;p&gt;The only real difference is the use of &lt;code class="docutils literal"&gt;async with httpx.AsyncClient() as client&lt;/code&gt; instead of
&lt;code class="docutils literal"&gt;async with aiohttp.ClientSession() as session&lt;/code&gt;.
&lt;code class="docutils literal"&gt;asyncio.run()&lt;/code&gt; was introduced in Python 3.7 and is the new way to run an async function.&lt;/p&gt;
&lt;p&gt;Save the file and run it in the command line after exporting your GitLab access token.&lt;/p&gt;
&lt;p&gt;In Unix / Mac OS:&lt;/p&gt;
&lt;pre class="literal-block"&gt;export GL_ACCESS_TOKEN=&amp;lt;your token&amp;gt;&lt;/pre&gt;
&lt;p&gt;In Windows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;set GL_ACCESS_TOKEN=&amp;lt;your token&amp;gt;&lt;/pre&gt;
&lt;pre class="literal-block"&gt;python3 -m create_issue&lt;/pre&gt;
&lt;p&gt;There should be a new issue created in the strange-relationship project. Check it out:
&lt;a class="reference external" href="https://gitlab.com/beenje/strange-relationship/issues"&gt;https://gitlab.com/beenje/strange-relationship/issues&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="using-starlette-to-build-a-gitlab-bot"&gt;
&lt;h2&gt;Using Starlette to build a GitLab bot&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; provides a &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/aiohttp.html"&gt;GitLabBot class&lt;/a&gt; to create an aiohttp
web server that reponds to GitLab webhooks.
Let's build the equivalent of the following aiohttp based bot with &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;from gidgetlab.aiohttp import GitLabBot

bot = GitLabBot("beenje")


@bot.router.register("Issue Hook", action="open")
async def issue_opened_event(event, gl, *args, **kwargs):
    """Whenever an issue is opened, greet the author and say thanks."""
    url = f"/projects/{event.project_id}/issues/{event.object_attributes['iid']}/notes"
    message = f"Thanks for the report @{event.data['user']['username']}! I will look into it ASAP! (I'm a bot)."
    await gl.post(url, data={"body": message})


if __name__ == "__main__":
    bot.run()&lt;/pre&gt;
&lt;div class="section" id="starlette-bot"&gt;
&lt;h3&gt;Starlette bot&lt;/h3&gt;
&lt;p&gt;In the same virtual environment as before install &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; and uvicorn:&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3 -m pip install starlette uvicorn&lt;/pre&gt;
&lt;p&gt;Save the following in a file named &lt;code class="docutils literal"&gt;bot.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import os
import httpx
import gidgetlab.routing
import gidgetlab.sansio
import gidgetlab.httpx
from starlette.applications import Starlette
from starlette.requests import Request
from starlette.responses import Response
from starlette.routing import Route

router = gidgetlab.routing.Router()


@router.register("Issue Hook", action="open")
async def issue_opened_event(event, gl, *args, **kwargs):
    """Whenever an issue is opened, greet the author and say thanks."""
    url = f"/projects/{event.project_id}/issues/{event.object_attributes['iid']}/notes"
    message = f"Thanks for the report @{event.data['user']['username']}! I will look into it ASAP! (I'm a bot)."
    await gl.post(url, data={"body": message})


async def webhook(request: Request) -&amp;gt; Response:
    """Handler that processes GitLab webhook requests"""
    body = await request.body()
    secret = os.environ.get("GL_SECRET")
    event = gidgetlab.sansio.Event.from_http(request.headers, body, secret=secret)
    async with httpx.AsyncClient() as client:
        gl = gidgetlab.httpx.GitLabAPI(
            client, "gidgetlab", access_token=os.environ.get("GL_ACCESS_TOKEN")
        )
        await router.dispatch(event, gl)
    return Response(status_code=200)


app = Starlette(routes=[Route("/", webhook, methods=["POST"])])&lt;/pre&gt;
&lt;p&gt;The Issue Hook handler is exactly the same as when using aiohttp.
gidgetlab abstracts away the HTTP client used.
To implement the bot, the only thing needed is an endpoint to handle webhook POST requests.&lt;/p&gt;
&lt;p&gt;Run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;uvicorn --reload bot:app
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [40232] using statreload
INFO:     Started server process [40234]
INFO:     Waiting for application startup.
INFO:     Application startup complete.&lt;/pre&gt;
&lt;p&gt;That's it. We have an ASGI server running on port 8000 that can receive events from GitLab.
We could test it by using ngrok as in the previous post.
This time we'll just fake some events using &lt;a class="reference external" href="https://httpie.org"&gt;httpie&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="testing-with-httpie"&gt;
&lt;h3&gt;Testing with httpie&lt;/h3&gt;
&lt;p&gt;For testing purpose, let's add a dummy event handler that is easy to trigger.&lt;/p&gt;
&lt;pre class="literal-block"&gt;@router.register("Push Hook")
async def dummy_action_on_push(event, gl, *args, **kwargs):
    print(f"Received {event.event}")
    print("Triggering some action...")
    await gl.sleep(1)
    print("Action done")&lt;/pre&gt;
&lt;p&gt;In one terminal, run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;uvicorn --reload bot:app&lt;/pre&gt;
&lt;p&gt;In another one:&lt;/p&gt;
&lt;pre class="literal-block"&gt;http POST 127.0.0.1:8000  "X-Gitlab-Event:Push Hook" Content-Type:application/json&lt;/pre&gt;
&lt;p&gt;You should see the following output in each respective terminal:&lt;/p&gt;
&lt;pre class="literal-block"&gt;Received Push Hook
Triggering some action...
Action done
INFO:     127.0.0.1:58814 - "POST / HTTP/1.1" 200 OK

HTTP/1.1 200 OK
date: Wed, 27 May 2020 20:39:02 GMT
server: uvicorn
transfer-encoding: chunked&lt;/pre&gt;
&lt;p&gt;If you want to use a secret you should pass it on both sides:&lt;/p&gt;
&lt;pre class="literal-block"&gt;export GL_SECRET=12345
uvicorn --reload bot:app


http POST 127.0.0.1:8000 x-gitlab-token:12345 "X-Gitlab-Event:Push Hook" Content-Type:application/json&lt;/pre&gt;
&lt;p&gt;You can see both examples on the following screenshot.&lt;/p&gt;
&lt;img alt="/images/gitlab-bot-starlette/httpie-push-hook.png" src="http://beenje.github.io/blog/images/gitlab-bot-starlette/httpie-push-hook.png"&gt;
&lt;/div&gt;
&lt;div class="section" id="starlette-startup-and-shutdown-events"&gt;
&lt;h3&gt;Starlette startup and shutdown events&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; can register event handlers to run on startup and shutdown.
Instead of creating a new httpx client on every new request, we could re-use the same.&lt;/p&gt;
&lt;pre class="literal-block"&gt;async def create_client() -&amp;gt; None:
    """Startup handler that creates the GitLabAPI instance"""
    client = httpx.AsyncClient()
    app.state.gl = gidgetlab.httpx.GitLabAPI(
        client, "gidgetlab", access_token=os.environ.get("GL_ACCESS_TOKEN")
    )


async def close_client() -&amp;gt; None:
    """Shutdown handler that closes the httpx client"""
    await app.state.gl._client.aclose()


async def webhook(request: Request) -&amp;gt; Response:
    """Handler that processes GitLab webhook requests"""
    body = await request.body()
    secret = os.environ.get("GL_SECRET")
    event = gidgetlab.sansio.Event.from_http(request.headers, body, secret=secret)
    await router.dispatch(event, request.app.state.gl)
    return Response(status_code=200)


app = Starlette(
    routes=[Route("/", webhook, methods=["POST"])],
    on_startup=[create_client],
    on_shutdown=[close_client],
)&lt;/pre&gt;
&lt;p&gt;In the &lt;code class="docutils literal"&gt;create_client&lt;/code&gt; function, we also store the GitLabAPI instance on the &lt;code class="docutils literal"&gt;app.state&lt;/code&gt;.
This allows us to access it using &lt;code class="docutils literal"&gt;request.app&lt;/code&gt; in the request and to close the httpx client on application shutdown.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="background-tasks"&gt;
&lt;h3&gt;Background tasks&lt;/h3&gt;
&lt;p&gt;In the above code, the &lt;code class="docutils literal"&gt;Response&lt;/code&gt; is only sent when all the dispatched event handlers have been executed.
Some event handlers might take some time to run if you trigger many actions or you might want to sleep
(&lt;code class="docutils literal"&gt;asyncio.sleep&lt;/code&gt; of course not to block the event loop) between different actions.
You probably noticed that's actually exactly what I did in my dummy push hook handler.&lt;/p&gt;
&lt;p&gt;To illustrate that let's increase the sleep and print the date in our handler:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import datetime


@router.register("Push Hook")
async def dummy_action_on_push(event, gl, *args, **kwargs):
    print(f"Received {event.event}")
    print(f"Triggering some action at {datetime.datetime.utcnow()}...")
    await gl.sleep(5)
    print(f"Action done at {datetime.datetime.utcnow()}")&lt;/pre&gt;
&lt;p&gt;If we send a Push Hook event, we'll only get a response after 5 seconds. Not great...
We can see that the server isn't blocked. We can send several requests and they are
all processed in parallel. But the response is only sent after the event handler is done.&lt;/p&gt;
&lt;img alt="/images/gitlab-bot-starlette/event-blocking-response.png" src="http://beenje.github.io/blog/images/gitlab-bot-starlette/event-blocking-response.png"&gt;
&lt;p&gt;&lt;em&gt;Action done&lt;/em&gt; is printed before the 200 is sent.&lt;/p&gt;
&lt;p&gt;When receiving a webhook, you should send the HTTP response as fast as possible.
This is stated in GitLab's &lt;a class="reference external" href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#webhook-endpoint-tips"&gt;documentation&lt;/a&gt;:
Your endpoint should &lt;strong&gt;send its HTTP response as fast as possible&lt;/strong&gt;.
If you wait too long, GitLab may decide the hook failed and retry it.&lt;/p&gt;
&lt;p&gt;One way to achieve that would be to use a task queue like &lt;a class="reference external" href="http://celeryproject.org"&gt;Celery&lt;/a&gt; or &lt;a class="reference external" href="https://python-rq.org"&gt;RQ&lt;/a&gt; to run the event handlers.
I'm actually using &lt;a class="reference external" href="https://python-rq.org"&gt;RQ&lt;/a&gt; in an aiohttp bot I created.&lt;/p&gt;
&lt;p&gt;A nice feature of &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; is that you can attach a &lt;a class="reference external" href="https://www.starlette.io/background/"&gt;background task&lt;/a&gt; to a response.
We can thus run the &lt;code class="docutils literal"&gt;dispatch&lt;/code&gt; function as a &lt;code class="docutils literal"&gt;BackgroundTask&lt;/code&gt;. This will ensure that the response is sent
as soon as the event has been received and parsed:&lt;/p&gt;
&lt;pre class="literal-block"&gt;from starlette.background import BackgroundTask


async def webhook(request: Request) -&amp;gt; Response:
    """Handler that processes GitLab webhook requests"""
    body = await request.body()
    secret = os.environ.get("GL_SECRET")
    event = gidgetlab.sansio.Event.from_http(request.headers, body, secret=secret)
    task = BackgroundTask(router.dispatch, event, request.app.state.gl)
    return Response(status_code=200, background=task)&lt;/pre&gt;
&lt;p&gt;If we perform the same test as before we see that the event is dispatched only after the response was sent.
It doesn't matter how long each handler takes.&lt;/p&gt;
&lt;img alt="/images/gitlab-bot-starlette/event-background-task.png" src="http://beenje.github.io/blog/images/gitlab-bot-starlette/event-background-task.png"&gt;
&lt;p&gt;&lt;em&gt;Received Push Hook&lt;/em&gt; is printed after the 200 is sent.&lt;/p&gt;
&lt;p&gt;Of course handlers shouldn't block the event loop!
As &lt;code class="docutils literal"&gt;router.dispatch&lt;/code&gt; is an async function, &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; will just await on it.
If an event handler is performing some blocking action, it should be run in a thread or process pool.
Otherwise the above code is all that is required.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="better-error-handling"&gt;
&lt;h3&gt;Better error handling&lt;/h3&gt;
&lt;p&gt;One thing we didn't pay attention to is error handling.
What happens if &lt;code class="docutils literal"&gt;gidgetlab.sansio.Event.from_http&lt;/code&gt; raises an Exception?
&lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; will return a 500 (Internal Server Error) HTTP response.
That's the proper thing to do.
&lt;strong&gt;Your endpoint should ALWAYS return a valid HTTP response&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But in the bot logs, we can see that exception. Not very clean.&lt;/p&gt;
&lt;img alt="/images/gitlab-bot-starlette/unhandled-exception.png" src="http://beenje.github.io/blog/images/gitlab-bot-starlette/unhandled-exception.png"&gt;
&lt;p&gt;We should catch those exceptions and handle them properly.&lt;/p&gt;
&lt;pre class="literal-block"&gt;from starlette.responses import Response, PlainTextResponse


async def webhook(request: Request) -&amp;gt; Response:
    """Handler that processes GitLab webhook requests"""
    body = await request.body()
    secret = os.environ.get("GL_SECRET")
    try:
        event = gidgetlab.sansio.Event.from_http(request.headers, body, secret=secret)
    except gidgetlab.HTTPException as e:
        return PlainTextResponse(status_code=e.status_code, content=str(e))
    except gidgetlab.GitLabException as e:
        return PlainTextResponse(status_code=500, content=str(e))
    task = BackgroundTask(router.dispatch, event, request.app.state.gl)
    return Response(status_code=200, background=task)&lt;/pre&gt;
&lt;img alt="/images/gitlab-bot-starlette/handle-exceptions.png" src="http://beenje.github.io/blog/images/gitlab-bot-starlette/handle-exceptions.png"&gt;
&lt;p&gt;Much nicer now! Everything is in place for a production ready bot.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I really enjoyed working with &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt;. It made building a GitLab bot with &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; very easy.
We saw how to use &lt;a class="reference external" href="https://www.starlette.io/events/"&gt;Events&lt;/a&gt; and
&lt;a class="reference external" href="https://www.starlette.io/background/"&gt;Backroung Tasks&lt;/a&gt;. Being able to run the &lt;code class="docutils literal"&gt;dispatch&lt;/code&gt; function
in the background is really perfect for our bot.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.python-httpx.org"&gt;HTTPX&lt;/a&gt; and &lt;a class="reference external" href="https://www.starlette.io"&gt;Starlette&lt;/a&gt; are definitvely my go-to frameworks for my next bot!&lt;/p&gt;
&lt;p&gt;You can find the full source code used in this post on both GitLab and GitHub:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://gitlab.com/beenje/gitlab-bot-starlette"&gt;https://gitlab.com/beenje/gitlab-bot-starlette&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://github.com/beenje/gitlab-bot-starlette"&gt;https://github.com/beenje/gitlab-bot-starlette&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>asyncio</category><category>bot</category><category>gidgetlab</category><category>gitlab</category><category>httpie</category><category>httpx</category><category>python</category><category>starlette</category><guid>http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-starlette-and-httpx/</guid><pubDate>Sun, 31 May 2020 19:51:53 GMT</pubDate></item><item><title>Building a GitLab bot using gidgetlab and aiohttp</title><link>http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-and-aiohttp/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;At PyCon 2018, &lt;a class="reference external" href="https://github.com/Mariatta"&gt;Mariatta&lt;/a&gt; held a &lt;a class="reference external" href="https://us.pycon.org/2018/schedule/presentation/41/"&gt;Build-a-GitHub-Bot Workshop&lt;/a&gt;. The full
documentation can be found on &lt;a class="reference external" href="https://github.com/Mariatta/github-bot-tutorial"&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I went through the tutorial and really enjoyed it.
This is how I discovered &lt;a class="reference external" href="https://gidgethub.readthedocs.io/en/latest/"&gt;gidgethub&lt;/a&gt; from &lt;a class="reference external" href="https://github.com/brettcannon"&gt;Brett Cannon&lt;/a&gt;, an async GitHub
API library for Python.&lt;/p&gt;
&lt;p&gt;I use GitLab at work and really wanted to do the same thing. So I created
&lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt;, a clone of &lt;a class="reference external" href="https://gidgethub.readthedocs.io/en/latest/"&gt;gidgethub&lt;/a&gt; for GitLab.&lt;/p&gt;
&lt;p&gt;In this post I want to demonstrate how to build a GitLab bot in the exact
same way. My goal is not to repeat the full &lt;a class="reference external" href="https://github-bot-tutorial.readthedocs.io/en/latest/"&gt;github-bot-tutorial&lt;/a&gt;
but to show the differences for GitLab. So I strongly suggest that you check the
&lt;a class="reference external" href="https://github-bot-tutorial.readthedocs.io/en/latest/"&gt;github-bot-tutorial&lt;/a&gt; first. I won't go in as much details.&lt;/p&gt;
&lt;p&gt;Note that this post will describe how to interact with gitlab.com but
gidgetlab can of course be used with a private GitLab instance!&lt;/p&gt;
&lt;div class="section" id="using-gidgetlab-on-the-command-line"&gt;
&lt;h2&gt;Using gidgetlab on the command line&lt;/h2&gt;
&lt;p&gt;This is the equivalent of &lt;a class="reference external" href="https://github-bot-tutorial.readthedocs.io/en/latest/gidgethub-cmd-line.html"&gt;using gidgethub on the command line&lt;/a&gt;.
So let's create an issue on GitLab using the API via the command line, instead of the GitLab website.&lt;/p&gt;
&lt;div class="section" id="install-gidgetlab-and-aiohttp"&gt;
&lt;h3&gt;Install gidgetlab and aiohttp&lt;/h3&gt;
&lt;p&gt;Install &lt;code class="docutils literal"&gt;gidgetlab&lt;/code&gt; and &lt;code class="docutils literal"&gt;aiohttp&lt;/code&gt; if you have not already. Using a virtual environment
is recommended.&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3.6 -m pip install gidgetlab[aiohttp]&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="create-a-gitlab-personal-access-token"&gt;
&lt;h3&gt;Create a GitLab Personal Access Token&lt;/h3&gt;
&lt;p&gt;In order to use GitLab's API, you'll need to create a personal access token
that will be used to authenticate yourself to GitLab.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;Go to &lt;a class="reference external" href="https://gitlab.com/profile/personal_access_tokens"&gt;https://gitlab.com/profile/personal_access_tokens&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Or, from GitLab, go to your &lt;a class="reference external" href="https://gitlab.com/profile"&gt;Settings&lt;/a&gt; &amp;gt; &lt;a class="reference external" href="https://gitlab.com/profile/personal_access_tokens"&gt;Access Tokens&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Under &lt;code class="docutils literal"&gt;Name&lt;/code&gt;, enter a short description, to identify the purpose
of this token. I recommend something like: &lt;code class="docutils literal"&gt;bot tutorial&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol class="arabic" start="4"&gt;
&lt;li&gt;&lt;p&gt;Under Scopes, check the &lt;code class="docutils literal"&gt;api&lt;/code&gt; scope.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;code class="docutils literal"&gt;Create personal access token&lt;/code&gt;. You will see your new personal access token
(a 21 characters string). Click on the copy to clipboard icon and and paste it locally
in a text file for now. If you have a password manager like 1password, use that.&lt;/p&gt;
&lt;p&gt;This is the only time you'll see this token in GitLab. If you lose it, you'll
need to revoke it and create another one.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="store-the-personal-access-token-as-an-environment-variable"&gt;
&lt;h3&gt;Store the Personal Access Token as an environment variable&lt;/h3&gt;
&lt;p&gt;In Unix / Mac OS:&lt;/p&gt;
&lt;pre class="literal-block"&gt;export GL_ACCESS_TOKEN=your token&lt;/pre&gt;
&lt;p&gt;In Windows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;set GL_ACCESS_TOKEN=your token&lt;/pre&gt;
&lt;p&gt;Note that these will only set the token for the current process. If you want
this value stored permanently, you have to edit the bashrc file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="create-an-issue"&gt;
&lt;h3&gt;Create an issue&lt;/h3&gt;
&lt;p&gt;Open a new file, for example &lt;code class="docutils literal"&gt;create_issue.py&lt;/code&gt; in your favorite editor.&lt;/p&gt;
&lt;p&gt;Copy the following into &lt;code class="docutils literal"&gt;create_issue.py&lt;/code&gt;.
Instead of "beenje" however, use your own GitLab username:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import asyncio
import os
import aiohttp
from gidgetlab.aiohttp import GitLabAPI

async def main():
    async with aiohttp.ClientSession() as session:
        gl = GitLabAPI(session, "beenje", access_token=os.getenv("GL_ACCESS_TOKEN"))

loop = asyncio.get_event_loop()
loop.run_until_complete(main())&lt;/pre&gt;
&lt;p&gt;We only instantiate a GitLabAPI class from gidgetlab by passing who we are ("beenje" in this example)
and our GitLab personal access token stored in the &lt;code class="docutils literal"&gt;GL_ACCESS_TOKEN&lt;/code&gt; environment variable.
Note that to interact with a private GitLab instance, you just have to pass the url to GitLabAPI:&lt;/p&gt;
&lt;pre class="literal-block"&gt;gl = GitLabAPI(session, "beenje", access_token=os.getenv("GL_ACCESS_TOKEN"),
               url="https://mygitlab.example.com")&lt;/pre&gt;
&lt;p&gt;By default, the url is set to &lt;cite&gt;https://gitlab.com&lt;/cite&gt;.&lt;/p&gt;
&lt;p&gt;So let's create an issue in one of my personal repo.
Take a look at GitLab's documentation for &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/issues.html#new-issue"&gt;creating a new issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To create an issue, you should make a &lt;code class="docutils literal"&gt;POST&lt;/code&gt; request to the url
&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;/projects/:id/issues&lt;/span&gt;&lt;/code&gt; and supply the parameters &lt;code class="docutils literal"&gt;title&lt;/code&gt; (required)
and &lt;code class="docutils literal"&gt;description&lt;/code&gt;.
The &lt;code class="docutils literal"&gt;id&lt;/code&gt; can be the project ID or &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/README.html#namespaced-path-encoding"&gt;URL-encoded path of the project&lt;/a&gt; owned by the authenticated user.&lt;/p&gt;
&lt;p&gt;With gidgetlab, this looks like the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;await gl.post(
    "/projects/beenje%2Fstrange-relationship/issues",
    data={
        "title": "We got a problem",
        "description": "Use more emoji!",
    })&lt;/pre&gt;
&lt;p&gt;&lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;beenje%2Fstrange-relationship&lt;/span&gt;&lt;/code&gt; is the &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/README.html#namespaced-path-encoding"&gt;URL-encoded path of the project&lt;/a&gt;. We could have used the id &lt;code class="docutils literal"&gt;7898119&lt;/code&gt; instead.
The project ID can be found on the project main page.&lt;/p&gt;
&lt;p&gt;Add the above code right after you instantiate GitLabAPI.
Your file should now look like the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import asyncio
import os
import aiohttp
from gidgetlab.aiohttp import GitLabAPI


async def main():
    async with aiohttp.ClientSession() as session:
        gl = GitLabAPI(session, "beenje", access_token=os.getenv("GL_ACCESS_TOKEN"))
        await gl.post(
            "/projects/beenje%2Fstrange-relationship/issues",
            data={
                "title": "We got a problem",
                "description": "Use more emoji!",
            })


loop = asyncio.get_event_loop()
loop.run_until_complete(main())&lt;/pre&gt;
&lt;p&gt;Feel free to change the title and the body of the message.
Save and run it in the command line:&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3.6 -m create_issue&lt;/pre&gt;
&lt;p&gt;There should be a new issue created in the strange-relationship project. Check it out:
&lt;a class="reference external" href="https://gitlab.com/beenje/strange-relationship/issues"&gt;https://gitlab.com/beenje/strange-relationship/issues&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="comment-on-issue"&gt;
&lt;h3&gt;Comment on issue&lt;/h3&gt;
&lt;p&gt;Let's try a different exercise, to get ourselves more familiar with GitLab's API.
Take a look at GitLab's &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/issues.html#comments-on-issues"&gt;create a comment&lt;/a&gt; documentation: &lt;code class="docutils literal"&gt;POST &lt;span class="pre"&gt;/projects/:id/issues/:issue_iid/notes&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Leave a comment in the issue you just created:&lt;/p&gt;
&lt;pre class="literal-block"&gt;await gl.post(
    "/projects/beenje%2Fstrange-relationship/issues/1/notes",
    data={"body": "This is a comment"},
)&lt;/pre&gt;
&lt;p&gt;Replace &lt;code class="docutils literal"&gt;1&lt;/code&gt; with the issue number you created.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="close-the-issue"&gt;
&lt;h3&gt;Close the issue&lt;/h3&gt;
&lt;p&gt;Let's now close the issue that you've just created.&lt;/p&gt;
&lt;p&gt;Take a look at the documentation to &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/issues.html#edit-issue"&gt;edit an issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The method for editing an issue is &lt;code class="docutils literal"&gt;PUT&lt;/code&gt; instead of &lt;code class="docutils literal"&gt;POST&lt;/code&gt;, which we've
seen in the previous two examples. In addition, to close an issue, you're basically
editing an issue, and setting the &lt;code class="docutils literal"&gt;state_event&lt;/code&gt; to &lt;code class="docutils literal"&gt;close&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Use gidgetlab to close the issue:&lt;/p&gt;
&lt;pre class="literal-block"&gt;await gl.put(
    "/projects/beenje%2Fstrange-relationship/issues/1",
    data={"state_event": "close"},
)&lt;/pre&gt;
&lt;p&gt;Replace &lt;code class="docutils literal"&gt;1&lt;/code&gt; with the issue number you created.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="using-gidgetlab-to-respond-to-webhooks"&gt;
&lt;h2&gt;Using gidgetlab to respond to webhooks&lt;/h2&gt;
&lt;p&gt;In the previous example, we've been interacting with GitLab by doing actions:
making requests to GitLab. And we've been doing that locally on our own machine.&lt;/p&gt;
&lt;p&gt;In this section we'll use what we know so far and start building an actual bot:
a webserver that responds to GitLab webhook events.&lt;/p&gt;
&lt;div class="section" id="gitlabbot"&gt;
&lt;h3&gt;GitLabBot&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; actually provides a &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/aiohttp.html"&gt;GitLabBot class&lt;/a&gt; to easily create an aiohttp
web server that reponds to GitLab webhooks.&lt;/p&gt;
&lt;p&gt;Save the following in a file named &lt;code class="docutils literal"&gt;bot.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;from gidgetlab.aiohttp import GitLabBot

bot = GitLabBot("beenje")


if __name__ == "__main__":
    bot.run()&lt;/pre&gt;
&lt;p&gt;And run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3 bot.py
======== Running on http://0.0.0.0:8080 ========
(Press CTRL+C to quit)&lt;/pre&gt;
&lt;p&gt;That's it. You have an aiohttp web server running on port 8080.
Of course, it won't do that much. You'll have to register some events if
you want the bot to perform some actions. We'll see that later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="webhook-events"&gt;
&lt;h3&gt;Webhook events&lt;/h3&gt;
&lt;p&gt;When an event is triggered in GitLab, GitLab can notify you about the event by
sending a POST request along with the payload.&lt;/p&gt;
&lt;p&gt;Some example &lt;code class="docutils literal"&gt;events&lt;/code&gt; are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Issues events: any time an issue is created or an existing issue was updated/closed/reopened&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Push events: when you push to the repository except when pushing tags&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tag events: when you create (or delete) tags to the repository&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Build events: triggered on status change of a Build&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The complete list of events is listed &lt;a class="reference external" href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#events"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since GitLab needs to send you POST requests for the webhook, you should have a service running somewhere that GitLab can reach.
That's usually not on your laptop.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://github-bot-tutorial.readthedocs.io/en/latest/index.html"&gt;GitHub bot tutorial&lt;/a&gt; describes how to &lt;a class="reference external" href="http://github-bot-tutorial.readthedocs.io/en/latest/gidgethub-for-webhooks.html#deploy-to-heroku"&gt;deploy your webservice to Heroku&lt;/a&gt;.
Heroku is a platform as a service and makes it easy to deploy and run your app in the cloud.
There are alternatives and you can of course use on your own servers if you want.&lt;/p&gt;
&lt;p&gt;For testing purpose, you can actually use your own laptop thanks to &lt;a class="reference external" href="https://ngrok.com"&gt;ngrok&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ngrok"&gt;
&lt;h3&gt;Ngrok&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://ngrok.com"&gt;Ngrok&lt;/a&gt; exposes local servers behind NATs and firewalls to the public internet over secure tunnels.
It's an easy way to test locally a webservice.&lt;/p&gt;
&lt;p&gt;Check the installation instructions from the &lt;a class="reference external" href="https://ngrok.com/download"&gt;website&lt;/a&gt;.
Note that for simple tests, you don't have to register an account.&lt;/p&gt;
&lt;p&gt;If you have a webserver running locally on port 8080, you can expose it by running:&lt;/p&gt;
&lt;pre class="literal-block"&gt;ngrok http 8080&lt;/pre&gt;
&lt;p&gt;Something similar will appear:&lt;/p&gt;
&lt;pre class="literal-block"&gt;ngrok by @inconshreveable                                       (Ctrl+C to quit)

Session Status                online
Session Expires               7 hours, 59 minutes
Version                       2.2.8
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
Forwarding                    http://fb7fec7c.ngrok.io -&amp;gt; localhost:8080
Forwarding                    https://fb7fec7c.ngrok.io -&amp;gt; localhost:8080&lt;/pre&gt;
&lt;p&gt;You can access your local webservice using HTTP and even HTTPS!&lt;/p&gt;
&lt;pre class="literal-block"&gt;curl -X GET https://fb7fec7c.ngrok.io&lt;/pre&gt;
&lt;p&gt;This address can be accessed from anywhere!. You could give it to a friend or use it as a GitLab webhook.&lt;/p&gt;
&lt;p&gt;Ngrok even gives you a web interface on the port 4040 that allows you to inspect all the requests made to the service.
Just open &lt;a class="reference external" href="http://127.0.0.1:4040"&gt;http://127.0.0.1:4040&lt;/a&gt; in your browser.&lt;/p&gt;
&lt;img alt="/images/gitlab-bot/ngrok-web-ui.png" src="http://beenje.github.io/blog/images/gitlab-bot/ngrok-web-ui.png"&gt;
&lt;p&gt;If your bot is still running and you tried to send a GET, you should get a
405 as reply. Only POST methods are handled by the bot.&lt;/p&gt;
&lt;p&gt;If you don't have any service listening on port 8080 and try to access the
URL given by ngrok, you'll get a 502.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-the-gitlab-webhook"&gt;
&lt;h3&gt;Add the GitLab Webhook&lt;/h3&gt;
&lt;p&gt;Now that we have a local webservice that can receive requests thanks to ngrok,
let's create a webhook on GitLab. If you haven't done so yet, create your
own project on GitLab.&lt;/p&gt;
&lt;p&gt;Go to your project settings and select Integrations to create a webhook:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;In the &lt;strong&gt;URL&lt;/strong&gt; field, enter the ngrok URL you got earlier.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For security reasons, type in some random characters under &lt;strong&gt;Secret Token&lt;/strong&gt; (you can use Python &lt;cite&gt;secrets.token_hex(16)&lt;/cite&gt; function)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Under &lt;strong&gt;Trigger&lt;/strong&gt;, select Issues events, Comments and Merge request events&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Leave &lt;strong&gt;Enable SSL verification&lt;/strong&gt; enabled&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;Add webhook&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="update-the-config-variables-in-your-environment"&gt;
&lt;h3&gt;Update the Config Variables in your environment&lt;/h3&gt;
&lt;p&gt;First, export the secret webhook token you just created:&lt;/p&gt;
&lt;pre class="literal-block"&gt;export GL_SECRET=&amp;lt;secret token&amp;gt;&lt;/pre&gt;
&lt;p&gt;Then, if not already done, export your GitLab personal access token:&lt;/p&gt;
&lt;pre class="literal-block"&gt;export GL_ACCESS_TOKEN=&amp;lt;acess token&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="your-first-gitlab-bot"&gt;
&lt;h3&gt;Your first GitLab bot!&lt;/h3&gt;
&lt;p&gt;Let's start with a bot that responds to every newly created issue in your project.
For example, whenever someone creates an issue, the bot will automatically say something like:
"Thanks for the report, @user. I will look into this ASAP!"&lt;/p&gt;
&lt;p&gt;To respond to webhooks events, we have to register a coroutine using the
&lt;code class="docutils literal"&gt;@bot.router.register&lt;/code&gt; decorator:&lt;/p&gt;
&lt;pre class="literal-block"&gt;@bot.router.register("Issue Hook", action="open")
async def issue_opened_event(event, gl, *args, **kwargs):
    pass&lt;/pre&gt;
&lt;p&gt;In this example we subscribe to the GitLab &lt;code class="docutils literal"&gt;Issue Hook&lt;/code&gt; events, and
more specifically to the "open" issues event.&lt;/p&gt;
&lt;p&gt;The two important parameters here are: &lt;code class="docutils literal"&gt;event&lt;/code&gt; and &lt;code class="docutils literal"&gt;gl&lt;/code&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal"&gt;event&lt;/code&gt; here is the representation of GitLab's webhook event. We can access the
event payload by doing &lt;code class="docutils literal"&gt;event.data&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class="docutils literal"&gt;gl&lt;/code&gt; is the gidgetlab GitLabAPI instance, which we can use to make API calls to GitLab, as in the first section.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We already saw that to &lt;a class="reference external" href="https://docs.gitlab.com/ee/api/issues.html#comments-on-issues"&gt;create a comment&lt;/a&gt; on an issue, we need to send: &lt;code class="docutils literal"&gt;POST &lt;span class="pre"&gt;/projects/:id/issues/:issue_iid/notes&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let's look at the &lt;a class="reference external" href="https://docs.gitlab.com/ee/user/project/integrations/webhooks.html#issues-events"&gt;Issues events&lt;/a&gt;
payload to see how we can retrieve the required information:&lt;/p&gt;
&lt;pre class="literal-block"&gt;{
  "object_kind": "issue",
  "user": {
    "name": "Administrator",
    "username": "root",
    "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon"
  },
  "project": {
    "id": 1,
    "name":"Gitlab Test",
    "description":"Aut reprehenderit ut est.",
    "web_url":"http://example.com/gitlabhq/gitlab-test",
    "avatar_url":null,
    "git_ssh_url":"git@example.com:gitlabhq/gitlab-test.git",
    "git_http_url":"http://example.com/gitlabhq/gitlab-test.git",
    "namespace":"GitlabHQ",
    ...
  },
  "repository": {
    "name": "Gitlab Test",
    "url": "http://example.com/gitlabhq/gitlab-test.git",
    "description": "Aut reprehenderit ut est.",
    "homepage": "http://example.com/gitlabhq/gitlab-test"
  },
  "object_attributes": {
    "id": 301,
    "title": "New API: create/update/delete file",
    ...
    "state": "opened",
    "iid": 23,
    "url": "http://example.com/diaspora/issues/23",
    "action": "open"
  },
  ...
}&lt;/pre&gt;
&lt;p&gt;The project id can be retrieved as &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;event.data["project"]["id"]&lt;/span&gt;&lt;/code&gt;.
As this is quite common, &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt; procures a &lt;em&gt;project_id&lt;/em&gt; property to access it directly: &lt;code class="docutils literal"&gt;event.project_id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To get the issue id, we can use &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;event.data["object_attributes"]["iid"]&lt;/span&gt;&lt;/code&gt;. Again as accessing &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;event.data["object_attributes"]&lt;/span&gt;&lt;/code&gt; is quite common,
we can use the &lt;em&gt;object_attributes&lt;/em&gt; property: &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;event.object_attributes["iid"]&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The url to use is thus:&lt;/p&gt;
&lt;pre class="literal-block"&gt;url = f"/projects/{event.project_id}/issues/{event.object_attributes['iid']}/notes"&lt;/pre&gt;
&lt;p&gt;To greet the author, we have to retrieve the username from the event: &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;event.data["user"]["username"]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Open your &lt;code class="docutils literal"&gt;bot.py&lt;/code&gt; file and add the following coroutine to be called when
a new issue is opened:&lt;/p&gt;
&lt;pre class="literal-block"&gt;@bot.router.register("Issue Hook", action="open")
async def issue_opened_event(event, gl, *args, **kwargs):
    """Whenever an issue is opened, greet the author and say thanks."""
    url = f"/projects/{event.project_id}/issues/{event.object_attributes['iid']}/notes"
    message = f"Thanks for the report @{event.data['user']['username']}! I will look into it ASAP! (I'm a bot)."
    await gl.post(url, data={"body": message})&lt;/pre&gt;
&lt;p&gt;The full file should look like:&lt;/p&gt;
&lt;pre class="literal-block"&gt;from gidgetlab.aiohttp import GitLabBot

bot = GitLabBot("beenje")


@bot.router.register("Issue Hook", action="open")
async def issue_opened_event(event, gl, *args, **kwargs):
    """Whenever an issue is opened, greet the author and say thanks."""
    url = f"/projects/{event.project_id}/issues/{event.object_attributes['iid']}/notes"
    message = f"Thanks for the report @{event.data['user']['username']}! I will look into it ASAP! (I'm a bot)."
    await gl.post(url, data={"body": message})


if __name__ == "__main__":
    bot.run()&lt;/pre&gt;
&lt;p&gt;Run:&lt;/p&gt;
&lt;pre class="literal-block"&gt;python3 bot.py&lt;/pre&gt;
&lt;p&gt;Go to your project and open an issue. Wait a few seconds and refresh the
page. You should see a new comment added to the issue!&lt;/p&gt;
&lt;img alt="/images/gitlab-bot/gitlab-bot-say-thanks.png" src="http://beenje.github.io/blog/images/gitlab-bot/gitlab-bot-say-thanks.png"&gt;
&lt;p&gt;Congrats! You wrote your first GitLab bot!&lt;/p&gt;
&lt;p&gt;Of course, using ngrok on your laptop was for testing only.
To use it in production, you should deploy it to a server or the cloud.
You can check the GitHub bot tutorial to see how to &lt;a class="reference external" href="http://github-bot-tutorial.readthedocs.io/en/latest/gidgethub-for-webhooks.html#deploy-to-heroku"&gt;deploy your webservice to Heroku&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully this gave you an idea of what can be done with &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested, try to perform the other exercices described in the
&lt;a class="reference external" href="https://github-bot-tutorial.readthedocs.io/en/latest/"&gt;github-bot-tutorial&lt;/a&gt; but using GitLab. Don't hesitate to let me know if you use &lt;a class="reference external" href="https://gidgetlab.readthedocs.io/en/latest/"&gt;gidgetlab&lt;/a&gt;
to build something cool :-)
And check my post about &lt;a class="reference external" href="http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-starlette-and-httpx"&gt;building a GitLab bot with Starlette and HTTPX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Again, a big thanks to &lt;a class="reference external" href="https://github.com/Mariatta"&gt;Mariatta&lt;/a&gt; for her tutorial and to &lt;a class="reference external" href="https://github.com/brettcannon"&gt;Brett Cannon&lt;/a&gt; for
&lt;a class="reference external" href="https://gidgethub.readthedocs.io/en/latest/"&gt;gidgethub&lt;/a&gt;! This project wouldn't exist otherwise.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>aiohttp</category><category>bot</category><category>gidgetlab</category><category>gitlab</category><category>python</category><guid>http://beenje.github.io/blog/posts/building-a-gitlab-bot-using-gidgetlab-and-aiohttp/</guid><pubDate>Mon, 17 Sep 2018 20:40:15 GMT</pubDate></item></channel></rss>