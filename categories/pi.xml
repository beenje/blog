<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tchut-Tchut Blog (Posts about pi)</title><link>http://beenje.github.io/blog/</link><description></description><atom:link href="http://beenje.github.io/blog/categories/pi.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:beenje@gmail.com"&gt;Benjamin Bertrand&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Sun, 03 May 2020 21:40:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Experimenting with asyncio on a Raspberry Pi</title><link>http://beenje.github.io/blog/posts/experimenting-with-asyncio-on-a-raspberry-pi/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;In a previous post, I described how I built a &lt;a class="reference external" href="http://beenje.github.io/blog/posts/my-lego-macintosh-classic-with-raspberry-pi-and-e-paper-display"&gt;LEGO Macintosh Classic with
a Raspberry Pi and e-paper display&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For testing purpose I installed the clock demo which is part of the
&lt;a class="reference external" href="https://github.com/embeddedartists/gratis"&gt;Embedded Artists repository&lt;/a&gt;.
Of course I wanted to do more than displaying the time on this little box.
I also wanted to take advantage of the button I had integrated.&lt;/p&gt;
&lt;p&gt;One idea was to create a small web server so that I could receive and display
messages. The application would basically:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;display the time (every minute)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;when receiving a message, stop the clock and display the message&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;when the button is pressed, start the clock again&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt="/images/legomac/press_button.gif" src="http://beenje.github.io/blog/images/legomac/press_button.gif"&gt;
&lt;p&gt;I don't know about you, but this really makes me think &lt;strong&gt;event loop&lt;/strong&gt;!
I learnt asynchronous programming with &lt;a class="reference external" href="http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/"&gt;Dave Peticolas Twisted Introduction&lt;/a&gt;
a few years ago. If you are not familiar with asynchronous programming, I really recommend
it. I wrote a few applications using &lt;a class="reference external" href="https://twistedmatrix.com"&gt;Twisted&lt;/a&gt; but I haven't had
the opportunity to use asyncio yet. Here is a very good occasion!&lt;/p&gt;
&lt;div class="section" id="asyncio"&gt;
&lt;h2&gt;asyncio&lt;/h2&gt;
&lt;div class="section" id="rest-api-using-aiohttp"&gt;
&lt;h3&gt;REST API using aiohttp&lt;/h3&gt;
&lt;p&gt;There are already several asyncio web frameworks to build an HTTP server.
I decided to go with &lt;a class="reference external" href="http://aiohttp.readthedocs.io/en/stable/"&gt;aiohttp&lt;/a&gt;
which is kind of the default one.&lt;/p&gt;
&lt;p&gt;Using this &lt;a class="reference external" href="http://steelkiwi.com/blog/jwt-authorization-python-part-1-practise/"&gt;tutorial&lt;/a&gt; I
wrote a simple REST API using aiohttp. It uses JSON Web Tokens which is
something else I have been wanted to try.&lt;/p&gt;
&lt;p&gt;The API has only 3 endpoints:&lt;/p&gt;
&lt;pre class="literal-block"&gt;def setup_routes(app):
    app.router.add_get('/', index)
    app.router.add_post('/login', login)
    app.router.add_post('/messages', post_message)&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;cite&gt;/&lt;/cite&gt; to check that our token is valid&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;cite&gt;/login&lt;/cite&gt; to login&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;cite&gt;/messages&lt;/cite&gt; to post messages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="literal-block"&gt;async def login(request):
    config = request.app['config']
    data = await request.json()
    try:
        user = data['username']
        passwd = data['password']
    except KeyError:
        return web.HTTPBadRequest(reason='Invalid arguments')
    # We have only one user hard-coded in the config file...
    if user != config['username'] or passwd != config['password']:
        return web.HTTPBadRequest(reason='Invalid credentials')
    payload = {
        'user_id': 1,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(seconds=config['jwt_exp_delta_seconds'])
    }
    jwt_token = jwt.encode(payload, config['jwt_secret'], config['jwt_algorithm'])
    logger.debug(f'JWT token created for {user}')
    return web.json_response({'token': jwt_token.decode('utf-8')})


@login_required
async def post_message(request):
    if request.content_type != 'application/json':
        return web.HTTPBadRequest()
    data = await request.json()
    try:
        message = data['message']
    except KeyError:
        return web.HTTPBadRequest()
    logger.debug(f'Message received from {request.user}: {message}')
    return web.json_response({'message': message}, status=201)


@login_required
async def index(request):
    return web.json_response({'message': 'Welcome to LegoMac {}!'.format(request.user)})&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="raspberry-pi-gpio-and-asyncio"&gt;
&lt;h3&gt;Raspberry Pi GPIO and asyncio&lt;/h3&gt;
&lt;p&gt;The default Python package to control the Raspberry Pi GPIO seems to be
&lt;a class="reference external" href="https://pypi.python.org/pypi/RPi.GPIO"&gt;RPi.GPIO&lt;/a&gt;.
That's at least what is used in the &lt;a class="reference external" href="https://github.com/embeddedartists/gratis/blob/master/PlatformWithOS/demo/ImageDemoButton.py"&gt;ImageDemoButton.py from Embedded Artists&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An alternative is the &lt;a class="reference external" href="http://abyz.co.uk/rpi/pigpio/index.html"&gt;pigpio library&lt;/a&gt;
which provides a daemon to access the Raspberry Pi GPIO via a pipe or socket interface.
And someone (Pierre Rust) already created an aysncio based Python client
for the pigpio daemon: &lt;a class="reference external" href="https://github.com/PierreRust/apigpio"&gt;apigpio&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Exactly what I needed!
It's basically a (incomplete) port of the original Python client provided
with pigpio, but far sufficient for my need. I just want to get a
notification when pressing the button on top of the screen.&lt;/p&gt;
&lt;p&gt;There is an example how to achieve that: &lt;a class="reference external" href="https://github.com/PierreRust/apigpio/blob/master/samples/gpio_notification.py"&gt;gpio_notification.py&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="e-paper-display-and-asyncio"&gt;
&lt;h3&gt;E-paper display and asyncio&lt;/h3&gt;
&lt;p&gt;The last remaining piece is to make the e-paper display play nicely with
asyncio.&lt;/p&gt;
&lt;p&gt;The EPD driver uses the fuse library. It allows the display to be
represented as a virtual directory of files. So sending a command
consists of writing to a file.&lt;/p&gt;
&lt;p&gt;There is a library to add file support to asyncio: &lt;a class="reference external" href="https://github.com/Tinche/aiofiles"&gt;aiofiles&lt;/a&gt;.
The only thing I had to do was basically to wrap the file IO in &lt;a class="reference external" href="https://github.com/embeddedartists/gratis/blob/master/PlatformWithOS/demo/EPD.py"&gt;EPD.py&lt;/a&gt;
with aiofiles:&lt;/p&gt;
&lt;pre class="literal-block"&gt;async def _command(self, c):
    async with aiofiles.open(os.path.join(self._epd_path, 'command'), 'wb') as f:
        await f.write(c)&lt;/pre&gt;
&lt;p&gt;You can't use &lt;cite&gt;await&lt;/cite&gt; in a class &lt;cite&gt;__init__&lt;/cite&gt; method. So following some recommendations
from &lt;a class="reference external" href="https://stackoverflow.com/questions/33128325/how-to-set-class-attribute-with-await-in-init"&gt;stackoverflow&lt;/a&gt;,
I used the factory pattern and moved the actions requiring some IO to a classmethod:&lt;/p&gt;
&lt;pre class="literal-block"&gt;@classmethod
async def create(cls, *args, **kwargs):
    self = EPD(*args, **kwargs)
    async with aiofiles.open(os.path.join(self._epd_path, 'version')) as f:
        version = await f.readline()
        self._version = version.rstrip('\n')
    async with aiofiles.open(os.path.join(self._epd_path, 'panel')) as f:
        line = await f.readline()
        m = self.PANEL_RE.match(line.rstrip('\n'))
        if m is None:
            raise EPDError('invalid panel string')
        ...&lt;/pre&gt;
&lt;p&gt;To create an instance of the EPD class, use:&lt;/p&gt;
&lt;pre class="literal-block"&gt;epd = await EPD.create([path='/path/to/epd'], [auto=boolean])&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="putting-everything-together-with-aiohttp"&gt;
&lt;h2&gt;Putting everything together with aiohttp&lt;/h2&gt;
&lt;div class="section" id="running-the-clock-as-a-background-task"&gt;
&lt;h3&gt;Running the clock as a background task&lt;/h3&gt;
&lt;p&gt;For the clock, I adapted the &lt;a class="reference external" href="https://github.com/embeddedartists/gratis/blob/master/PlatformWithOS/demo/Clock27.py"&gt;clock demo&lt;/a&gt;
from Embedded Artists repository.&lt;/p&gt;
&lt;p&gt;As described in aiohttp documentation I created a &lt;a class="reference external" href="http://aiohttp.readthedocs.io/en/stable/web.html#background-tasks"&gt;background task&lt;/a&gt; to display the clock
every minute:&lt;/p&gt;
&lt;pre class="literal-block"&gt;async def display_clock(app):
    """Background task to display clock every minute"""
    clock = Clock(app['epd'])
    first_start = True
    try:
        while True:
            while True:
                now = datetime.datetime.today()
                if now.second == 0 or first_start:
                    first_start = False
                    break
                await asyncio.sleep(0.5)
            logger.debug('display clock')
            await clock.display(now)
    except asyncio.CancelledError:
        logger.debug('display clock cancel')


async def start_background_tasks(app):
     app['epd'] = await EPD.create(auto=True)
     app['clock'] = app.loop.create_task(display_clock(app))


async def cleanup_background_tasks(app):
    app['clock'].cancel()
    await app['clock']


def init_app():
    """Create and return the aiohttp Application object"""
    app = web.Application()
    app.on_startup.append(start_background_tasks)
    app.on_cleanup.append(cleanup_background_tasks)
    ...&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="stop-the-clock-and-display-a-message"&gt;
&lt;h3&gt;Stop the clock and display a message&lt;/h3&gt;
&lt;p&gt;When receiving a message, I first cancel the clock background task and
send the messages to the e-paper display using &lt;cite&gt;ensure_future&lt;/cite&gt; so that
I can return a json response without having to wait for the message to be
displayed as it takes about 5 seconds:&lt;/p&gt;
&lt;pre class="literal-block"&gt;@login_required
async def post_message(request):
    if request.content_type != 'application/json':
        return web.HTTPBadRequest()
    data = await request.json()
    try:
        message = data['message']
    except KeyError:
        return web.HTTPBadRequest()
    # cancel the display clock
    request.app['clock'].cancel()
    logger.debug(f'Message received from {request.user}: {message}')
    now = datetime.datetime.now(request.app['timezone'])
    helpers.ensure_future(request.app['epd'].display_message(message, request.user, now))
    return web.json_response({'message': message}, status=201)&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="start-the-clock-when-pressing-the-button"&gt;
&lt;h3&gt;Start the clock when pressing the button&lt;/h3&gt;
&lt;p&gt;To be able to restart the clock when pressing the button, I connect to the
pigpiod when starting the app (in &lt;cite&gt;start_background_tasks&lt;/cite&gt;) and register
the &lt;cite&gt;on_input&lt;/cite&gt; callback:&lt;/p&gt;
&lt;pre class="literal-block"&gt;async def start_background_tasks(app):
    app['pi'] = apigpio.Pi(app.loop)
    address = (app['config']['pigpiod_host'], app['config']['pigpiod_port'])
    await app['pi'].connect(address)
    await app['pi'].set_mode(BUTTON_GPIO, apigpio.INPUT)
    app['cb'] = await app['pi'].add_callback(
            BUTTON_GPIO,
            edge=apigpio.RISING_EDGE,
            func=functools.partial(on_input, app))
    ...&lt;/pre&gt;
&lt;p&gt;In the &lt;cite&gt;on_input&lt;/cite&gt; callback, I re-create the clock background task but only if the previous
task is done:&lt;/p&gt;
&lt;pre class="literal-block"&gt;def on_input(app, gpio, level, tick):
    """Callback called when pressing the button on the e-paper display"""
    logger.info('on_input {} {} {}'.format(gpio, level, tick))
    if app['clock'].done():
        logger.info('restart clock')
        app['clock'] = app.loop.create_task(display_clock(app))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="running-on-the-pi"&gt;
&lt;h2&gt;Running on the Pi&lt;/h2&gt;
&lt;p&gt;You might have noticed that I used some syntax that is Python 3.6 only.
I don't really see myself using something else when starting a new project
today :-)
There are so many new things (like f-strings) that make your programs look
cleaner.&lt;/p&gt;
&lt;p&gt;On raspbian, if you install Python 3, you get 3.4... So how do you get Python 3.6 on
a Raspberry Pi?&lt;/p&gt;
&lt;p&gt;On desktop/server I usually use &lt;a class="reference external" href="https://conda.io/miniconda.html"&gt;conda&lt;/a&gt;. It makes it so easy to install
the Python version you want and many dependencies.
There are no official installer for the armv6 architecture but I
found &lt;a class="reference external" href="https://github.com/jjhelmus/berryconda"&gt;berryconda&lt;/a&gt; which is a
conda based distribution for the Raspberry Pi! Really nice!&lt;/p&gt;
&lt;p&gt;Another alternative is to use &lt;a class="reference external" href="https://www.docker.com"&gt;docker&lt;/a&gt;.
There are official &lt;a class="reference external" href="https://hub.docker.com/u/arm32v6/python"&gt;arm32v6 images&lt;/a&gt;
based on alpine and some from &lt;a class="reference external" href="https://hub.docker.com/r/resin/raspberry-pi-python/"&gt;resin.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I could have gone with berryconda, but there's one thing I wanted as well.
I'll have to open the HTTP server to the outside world meaning I need
HTTPS. As mentionned in another &lt;a class="reference external" href="http://beenje.github.io/blog/post/running-your-application-over-https-with-traefik"&gt;post&lt;/a&gt;, &lt;a class="reference external" href="https://traefik.io"&gt;traefik&lt;/a&gt; makes
that very easy if you use docker. So that's what I chose.&lt;/p&gt;
&lt;p&gt;I created 3 containers:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;traefik&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pigpiod&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;aiolegomac&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="traefik"&gt;
&lt;h3&gt;traefik&lt;/h3&gt;
&lt;p&gt;There are no official Traefik docker images for arm yet, but an &lt;a class="reference external" href="https://github.com/containous/traefik/issues/1665"&gt;issue&lt;/a&gt; is currently opened.
So it should arrive soon!&lt;/p&gt;
&lt;p&gt;In the meantime I created my own:&lt;/p&gt;
&lt;pre class="literal-block"&gt;FROM arm32v6/alpine:3.6

RUN apk --update upgrade \
  &amp;amp;&amp;amp; apk --no-cache --no-progress add ca-certificates \
  &amp;amp;&amp;amp; apk add openssl \
  &amp;amp;&amp;amp; rm -rf /var/cache/apk/*

RUN wget -O /usr/local/bin/traefik https://github.com/containous/traefik/releases/download/v1.3.3/traefik_linux-arm \
  &amp;amp;&amp;amp; chmod a+x /usr/local/bin/traefik

ENTRYPOINT ["/usr/local/bin/traefik"]&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pigpiod"&gt;
&lt;h3&gt;pigpiod&lt;/h3&gt;
&lt;p&gt;For pigpiod, I first created an image based on &lt;cite&gt;arm32v6/alpine&lt;/cite&gt; but I noticed I couldn't send
a SIGTERM to the daemon to stop it properly... I'm not sure why. Alpine being based on &lt;cite&gt;musl&lt;/cite&gt; instead
of &lt;cite&gt;glibc&lt;/cite&gt; might be the problem. Here is the Dockerfile I tried:&lt;/p&gt;
&lt;pre class="literal-block"&gt;FROM arm32v6/alpine:3.6

RUN apk add --no-cache --virtual .build-deps \
  gcc \
  make \
  musl-dev \
  tar \
  &amp;amp;&amp;amp; wget -O /tmp/pigpio.tar abyz.co.uk/rpi/pigpio/pigpio.tar \
  &amp;amp;&amp;amp; tar -xf /tmp/pigpio.tar -C /tmp \
  &amp;amp;&amp;amp; sed -i "/ldconfig/d" /tmp/PIGPIO/Makefile \
  &amp;amp;&amp;amp; make -C /tmp/PIGPIO \
  &amp;amp;&amp;amp; make -C /tmp/PIGPIO install \
  &amp;amp;&amp;amp; rm -rf /tmp/PIGPIO /tmp/pigpio.tar \
  &amp;amp;&amp;amp; apk del .build-deps

EXPOSE 8888

ENTRYPOINT ["/usr/local/bin/pigpiod", "-g"]&lt;/pre&gt;
&lt;p&gt;I even tried using &lt;a class="reference external" href="https://github.com/krallin/tini"&gt;tini&lt;/a&gt; as entrypoint without luck.
So if someone as the explanation, please share it in the comments.&lt;/p&gt;
&lt;p&gt;I tried with &lt;cite&gt;resin/rpi-raspbian&lt;/cite&gt; image and I got it working properly right away:&lt;/p&gt;
&lt;pre class="literal-block"&gt;FROM resin/rpi-raspbian:jessie

RUN apt-get update \
  &amp;amp;&amp;amp; apt-get install -y \
     make \
     gcc \
     libc6-dev \
  &amp;amp;&amp;amp; apt-get clean \
  &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

RUN curl -o /tmp/pigpio.tar abyz.co.uk/rpi/pigpio/pigpio.tar \
  &amp;amp;&amp;amp; tar -xf /tmp/pigpio.tar -C /tmp \
  &amp;amp;&amp;amp; make -C /tmp/PIGPIO \
  &amp;amp;&amp;amp; make -C /tmp/PIGPIO install \
  &amp;amp;&amp;amp; rm -rf /tmp/pigpio.tar /tmp/PIGPIO

EXPOSE 8888

ENTRYPOINT ["/usr/local/bin/pigpiod", "-g"]&lt;/pre&gt;
&lt;p&gt;Note that the container has to run in privileged mode to access the GPIO.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="aiolegomac"&gt;
&lt;h3&gt;aiolegomac&lt;/h3&gt;
&lt;p&gt;For the main application, the Dockerfile is quite standard for a Python application:&lt;/p&gt;
&lt;pre class="literal-block"&gt;FROM resin/raspberry-pi-python:3.6

RUN apt-get update \
  &amp;amp;&amp;amp; apt-get install -y \
     fonts-liberation \
     fonts-dejavu  \
     libjpeg-dev \
     libfreetype6-dev \
     libtiff5-dev \
     liblcms2-dev \
     libwebp-dev \
     zlib1g-dev \
     libyaml-0-2 \
  &amp;amp;&amp;amp; apt-get autoremove \
  &amp;amp;&amp;amp; apt-get clean \
  &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements.txt /app/requirements.txt
RUN python -m venv /opt/legomac \
  &amp;amp;&amp;amp; /opt/legomac/bin/pip install -r requirements.txt

COPY . /app

ENTRYPOINT ["/opt/legomac/bin/python"]
CMD ["run.py"]&lt;/pre&gt;
&lt;p&gt;What about the EPD driver?
As it uses libfuse to represent the e-paper display as a virtual directory of files,
the easiest was to install it on the host and to mount it as a volume inside the docker
container.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="deployment"&gt;
&lt;h2&gt;Deployment&lt;/h2&gt;
&lt;p&gt;To install all that on the Pi, I wrote a small &lt;a class="reference external" href="https://www.ansible.com"&gt;Ansible&lt;/a&gt; playbook.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;Configure the Pi as described in my &lt;a class="reference external" href="http://beenje.github.io/blog/posts/my-lego-macintosh-classic-with-raspberry-pi-and-e-paper-display"&gt;previous post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Clone the playbook:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ git clone https://github.com/beenje/legomac.git
$ cd legomac&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create a file &lt;cite&gt;host_vars/legomac&lt;/cite&gt; with your variables (assuming the hostname of the Pi is legomac):&lt;/p&gt;
&lt;pre class="literal-block"&gt;aiolegomac_hostname: myhost.example.com
aiolegomac_username: john
aiolegomac_password: mypassword
aiolegomac_jwt_secret: secret
traefik_letsencrypt_email: youremail@example.com
traefik_letsencrypt_production: true&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run the playbook:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ ansible-playbook -i hosts -k playbook.yml&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This will install docker and the EPD driver, download the &lt;a class="reference external" href="https://github.com/beenje/aiolegomac"&gt;aiolegomac repository&lt;/a&gt;, build the 3 docker images
and start everything.&lt;/p&gt;
&lt;p&gt;Building the main application docker image on a Raspberry Pi Zero takes quite some time.
So be patient :-) Just go and do something else.&lt;/p&gt;
&lt;p&gt;When the full playbook is complete (it took about 55 minutes for me),
you'll have a server with HTTPS support (thanks to Let's Encrypt) running on the Pi. It's displaying
the clock every minute and you can send messages to it!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="client"&gt;
&lt;h2&gt;Client&lt;/h2&gt;
&lt;div class="section" id="httpie"&gt;
&lt;h3&gt;HTTPie&lt;/h3&gt;
&lt;p&gt;To test the server you can of course use &lt;a class="reference external" href="https://curl.haxx.se"&gt;curl&lt;/a&gt;
but I really like &lt;a class="reference external" href="https://httpie.org"&gt;HTTPie&lt;/a&gt;. It's much more user
friendly.&lt;/p&gt;
&lt;p&gt;Let's try to access our new server:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ http GET https://myhost.example.com
HTTP/1.1 401 Unauthorized
Content-Length: 25
Content-Type: application/json; charset=utf-8
Date: Sun, 16 Jul 2017 06:22:42 GMT
Server: Python/3.6 aiohttp/2.2.3

{
    "error": "Unauthorized"
}&lt;/pre&gt;
&lt;p&gt;Good, we need to login:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ http POST https://myhost.example.com/login username=john password=foo
HTTP/1.1 400 Bad Request
Content-Length: 32
Content-Type: application/json; charset=utf-8
Date: Sun, 16 Jul 2017 06:18:39 GMT
Server: Python/3.6 aiohttp/2.2.3

{
    "error": "Invalid credentials"
}&lt;/pre&gt;
&lt;p&gt;Oops, wrong password:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ http POST https://myhost.example.com/login username=john password='mypassword'
HTTP/1.1 200 OK
Content-Length: 134
Content-Type: application/json; charset=utf-8
Date: Sun, 16 Jul 2017 06:21:14 GMT
Server: Python/3.6 aiohttp/2.2.3

{
    "token": "eyK0eXAiOiJRV5QiLCJhbGciOiJIUzI1NiJ9.eyJ1c3VyX2lkIjoxLCJleHAiOjE1MDB5MTIwOTh9.hECnj4u2mxvZ2r8IEC-db1T-eKTplM4kWJKZoHhtLxQ"
}&lt;/pre&gt;
&lt;p&gt;We got a token that we can use:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ http GET https://myhost.example.com 'Authorization: eyK0eXAiOiJRV5QiLCJhbGciOiJIUzI1NiJ9.eyJ1c3VyX2lkIjoxLCJleHAiOjE1MDB5MTIwOTh9.hECnj4u2mxvZ2r8IEC-db1T-eKTplM4kWJKZoHhtLxQ'
HTTP/1.1 200 OK
Content-Length: 43
Content-Type: application/json; charset=utf-8
Date: Sun, 16 Jul 2017 06:22:25 GMT
Server: Python/3.6 aiohttp/2.2.3

{
    "message": "Welcome to LegoMac john!"
}&lt;/pre&gt;
&lt;p&gt;Authentication is working, so we can send a message:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ http POST https://myhost.example.com/messages message='Hello World!' 'Authorization: eyK0eXAiOiJRV5QiLCJhbGciOiJIUzI1NiJ9.eyJ1c3VyX2lkIjoxLCJleHAiOjE1MDB5MTIwOTh9.hECnj4u2mxvZ2r8IEC-db1T-eKTplM4kWJKZoHhtLxQ'
HTTP/1.1 201 Created
Content-Length: 27
Content-Type: application/json; charset=utf-8
Date: Sun, 16 Jul 2017 06:23:46 GMT
Server: Python/3.6 aiohttp/2.2.3

{
    "message": "Hello World!"
}&lt;/pre&gt;
&lt;p&gt;Message sent!
HTTPie is nice for testing, but we can make a small script to easily send messages from the command line.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="requests"&gt;
&lt;h3&gt;requests&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="http://docs.python-requests.org"&gt;requests&lt;/a&gt; is of course the HTTP library to use in Python.&lt;/p&gt;
&lt;p&gt;So let's write a small script to send messages to our server.
We'll store the server url and username to use in a small yaml configuration file.
If we don't have a token yet or if the saved one is no longer valid,
the script will retrieve one after prompting us for a password.
The token is saved in the configuration file for later use.&lt;/p&gt;
&lt;p&gt;The following script could be improved with some nicer error messages
by catching exceptions. But it does the job:&lt;/p&gt;
&lt;pre class="literal-block"&gt;import os
import click
import requests
import yaml


def get_config(filename):
    with open(filename) as f:
        config = yaml.load(f)
    return config


def save_config(filename, config):
    with open(filename, 'w') as f:
        yaml.dump(config, f, default_flow_style=False)


def get_token(url, username):
    password = click.prompt('Password', hide_input=True)
    payload = {'username': username, 'password': password}
    r = requests.post(url + '/login', json=payload)
    r.raise_for_status()
    return r.json()['token']


def send_message(url, token, message):
    payload = {'message': message}
    headers = {'Authorization': token}
    r = requests.post(url + '/messages', json=payload, headers=headers)
    r.raise_for_status()


@click.command()
@click.option('--conf', '-c', default='~/.pylegomac.yml',
              help='Configuration file [default: "~/.pylegomac.yml"]')
@click.argument('message')
@click.version_option()
def pylegomac(message, conf):
    """Send message to aiolegomac server"""
    filename = os.path.expanduser(conf)
    config = get_config(filename)
    url = config['url']
    username = config['username']
    if 'token' in config:
        try:
            send_message(url, config['token'], message)
        except requests.exceptions.HTTPError as err:
            # Token no more valid
            pass
        else:
            click.echo('Message sent')
            return
    token = get_token(url, username)
    send_message(url, token, message)
    config['token'] = token
    save_config(filename, config)


if __name__ == '__main__':
    pylegomac()&lt;/pre&gt;
&lt;p&gt;Let's first create a configuration file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ cat ~/.pylegomac.yml
url: https://myhost.example.com
username: john&lt;/pre&gt;
&lt;p&gt;Send a message:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ python pylegomac.py 'Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated.'
Password:
Message sent&lt;/pre&gt;
&lt;img alt="/images/legomac/zen_of_python.jpg" src="http://beenje.github.io/blog/images/legomac/zen_of_python.jpg"&gt;
&lt;p&gt;Sending a new message won't request the password as the token was saved in the config file.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I have a nice little aiohttp server running on my Raspberry Pi that can receive and display messages.
asyncio is quite pleasant to work with. I really like the async/await syntax.&lt;/p&gt;
&lt;p&gt;All the code is on github:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://github.com/beenje/aiolegomac"&gt;aiolegomac&lt;/a&gt; (the server and client script)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a class="reference external" href="https://github.com/beenje/legomac"&gt;legomac&lt;/a&gt; (the Ansible playbook to deploy the server)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why did I only write a command line script to send messages and no web interface?
Don't worry, that's planned! I could have used Jinja2. But I'd like to try a javascript framework.
So that will be the subject of another post.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Ansible</category><category>docker</category><category>lego</category><category>pi</category><category>python</category><guid>http://beenje.github.io/blog/posts/experimenting-with-asyncio-on-a-raspberry-pi/</guid><pubDate>Tue, 18 Jul 2017 20:46:17 GMT</pubDate></item><item><title>My LEGO Macintosh Classic with Raspberry Pi and e-paper display</title><link>http://beenje.github.io/blog/posts/my-lego-macintosh-classic-with-raspberry-pi-and-e-paper-display/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;UPDATED 2019-11-24&lt;/p&gt;
&lt;p&gt;Beginning of April I read an inspiring blog post from Jannis Hermanns
about a &lt;a class="reference external" href="https://jann.is/lego-macintosh-classic/"&gt;LEGO Machintosh Classic with e-paper display&lt;/a&gt;.  It was a really nice and cool article.&lt;/p&gt;
&lt;p&gt;I've been playing with some Raspberry Pis before but only with
&lt;a class="reference external" href="http://beenje.github.io/blog/posts/installing-openvpn-on-a-raspberry-pi-with-ansible"&gt;software&lt;/a&gt;.
I have been willing to fiddle with hardware for some time.
This was the perfect opportunity!&lt;/p&gt;
&lt;div class="section" id="lego-digital-designer"&gt;
&lt;h2&gt;LEGO Digital Designer&lt;/h2&gt;
&lt;p&gt;I decided to try to make my own LEGO Macintosh based on Jannis work.
His blog post is quite detailed with even a list of links with all the
required components.&lt;/p&gt;
&lt;p&gt;But I quickly realized there were no LEGO building instructions...
I thus created my own using LEGO Digital Designer, which was fun.
Looking at the pictures on &lt;a class="reference external" href="https://www.flickr.com/photos/_-_/33583084842"&gt;Jannis flickr album&lt;/a&gt;
helped a lot. But having an exact idea of the screen size wasn't easy on
the computer. So I also built a small prototype of the front part to get a
better idea. For that I had to wait for my e-paper display.&lt;/p&gt;
&lt;p&gt;One modification I wanted to do was to use 1U width lego on the side of
the display to require less drilling.
I also wanted to check if it was possible to use the button located on top
of the display.&lt;/p&gt;
&lt;p&gt;My .lxf file is on &lt;a class="reference external" href="https://github.com/beenje/legomac/tree/master/ldd"&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/legomac_ldd.png"&gt;&lt;img alt="/images/legomac/legomac_ldd.thumbnail.png" src="http://beenje.github.io/blog/images/legomac/legomac_ldd.thumbnail.png"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="e-paper-display"&gt;
&lt;h2&gt;E-paper display&lt;/h2&gt;
&lt;p&gt;When I was about to order the &lt;a class="reference external" href="http://www.embeddedartists.com/products/displays/lcd_27_epaper.php"&gt;2.7 inch e-paper display from Embedded Artists&lt;/a&gt;, I
noticed that Embedded Artists was located in Malmö, where I live :-).&lt;/p&gt;
&lt;p&gt;I e-mailed them and I was granted to pick up my order at their office!
A big thanks to them!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="raspbery-pi-zero-w"&gt;
&lt;h2&gt;Raspbery Pi Zero W&lt;/h2&gt;
&lt;p&gt;The Raspberry Pi Zero W comes with Wifi which is really nice.
It does not come with the soldered GPIO header. I was starting to look at
existing soldering iron when I discovered this &lt;a class="reference external" href="https://shop.pimoroni.com/products/gpio-hammer-header"&gt;GPIO Hammer Header&lt;/a&gt;:&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/gpio_hammer_header.jpg"&gt;&lt;img alt="/images/legomac/gpio_hammer_header.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/gpio_hammer_header.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;p&gt;No soldering required!
I used the installation jig and it was really easy to install.
There is a nice &lt;a class="reference external" href="https://youtu.be/VDJ2-feg2lk"&gt;video&lt;/a&gt; that explains how
to proceed:&lt;/p&gt;
&lt;iframe width="480" height="270" src="https://www.youtube.com/embed/VDJ2-feg2lk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;div class="section" id="connecting-the-display-to-the-pi"&gt;
&lt;h2&gt;Connecting the display to the Pi&lt;/h2&gt;
&lt;p&gt;Based on Jannis article I initially thought it wasn't possible to use a ribbon
cable (due to space), so I ordered some Jumper Wires.
I connected the display to the Pi using the serial expansion
connector as described in his blog post.
It worked. With the &lt;a class="reference external" href="https://github.com/embeddedartists/gratis"&gt;demo from embeddedartists&lt;/a&gt;, I managed to display a nice cat picture :-)&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/jumper_wires.jpg"&gt;&lt;img alt="/images/legomac/jumper_wires.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/jumper_wires.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/cat.jpg"&gt;&lt;img alt="/images/legomac/cat.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/cat.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;p&gt;I then realized that the serial expansion connector didn't give access to
the button on top of the display. That button could allow some
interactions, like changing mode, which would be nice.
According to my prototype with 1U width lego on the side, using a ribbon cable shouldn't actually be
an issue. So I ordered a &lt;a class="reference external" href="https://thepihut.com/products/downgrade-gpio-ribbon-cable-for-raspberry-pi-40p-to-26p"&gt;Downgrade GPIO Ribbon Cable for Raspberry Pi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It required a little drilling on the right side for the cable to fit. But
not that much. More is needed on the left side to center the screen.
Carried away by my enthusiasm, I actually cut a bit too much on the left side
(using the dremel was fun :-).&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/drilling_left.jpg"&gt;&lt;img alt="/images/legomac/drilling_left.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/drilling_left.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/drilling_right.jpg"&gt;&lt;img alt="/images/legomac/drilling_right.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/drilling_right.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;p&gt;Everything fitted nicely in the lego case:&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/ribbon_cable.jpg"&gt;&lt;img alt="/images/legomac/ribbon_cable.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/ribbon_cable.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="button-on-top"&gt;
&lt;h2&gt;Button on top&lt;/h2&gt;
&lt;p&gt;With the ribbon cable, the button on top of the display is connected to pin
15 on the Raspberry Pi (BCM GPIO22).
The &lt;cite&gt;ImageDemoButton.py&lt;/cite&gt; part of the &lt;a class="reference external" href="https://github.com/embeddedartists/gratis"&gt;demo&lt;/a&gt;
shows an example how to use the button to change the image displayed.&lt;/p&gt;
&lt;p&gt;Using my small prototype, I planned a small hole on top of the case. I thought I'd have to fill
the brick with something hard to press the button. The 1x1 brick ended fitting perfectly.
As shown on the picture below, the side is exactly on top of the button.
I added a little piece of foam inside the brick to keep it straight.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/button_front.jpg"&gt;&lt;img alt="/images/legomac/button_front.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/button_front.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;p&gt;Of course I move away from the Macintosh Classic design here...
but &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0020/"&gt;practicality beats purity&lt;/a&gt; :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pi-configuration"&gt;
&lt;h2&gt;Pi configuration&lt;/h2&gt;
&lt;p&gt;Jannis article made me discover &lt;a class="reference external" href="https://resin.io"&gt;resin.io&lt;/a&gt;,
which is a really interesting project. I did a few tests on a Raspberry Pi 3 and it was a nice experience.
But when I received my Pi Zero W, it wasn't supported by resinOS yet... This isn't the case anymore!
Version 2.0.3 added support for the wifi chip.&lt;/p&gt;
&lt;p&gt;Anyway, as Jannis already wrote about resinOS, I'll describe my tests with Raspbian.
To flash the SD card, I recommend &lt;a class="reference external" href="https://etcher.io"&gt;Etcher&lt;/a&gt; which is an open source project by the same resin.io.
I'm more a command line guy and I have used &lt;cite&gt;dd&lt;/cite&gt; many times. But I was pleasantly surprised.
It's easy to install and use.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;Download and install &lt;a class="reference external" href="https://etcher.io"&gt;Etcher&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Download &lt;a class="reference external" href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian Buster Lite image&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Flash the SD card using Etcher&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mount the SD card to configure it:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;# Go to the boot partition
# This is an example on OSX (mount point will be different on Linux)
$ cd /Volumes/boot

# To enable ssh, create a file named ssh onto the boot partition
$ touch ssh

# Create the file wpa_supplicant.conf with your wifi settings
# Note that for Raspbian Stretch and Buster, you need the first line
# (ctrl_interface...)! This was not the case for Jessie.
$  cat &amp;lt;&amp;lt; EOF &amp;gt; wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
network={
    ssid="MyWifiNetwork"
    psk="password"
    key_mgmt=WPA-PSK
}
EOF

# Uncomment dtparam=spi=on to enable the SPI master driver
$ vi config.txt

# Leave the boot partition
$ cd&lt;/pre&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;&lt;p&gt;Unmount the SD card and put it in the Raspberry Pi&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Boot the Pi&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I wrote a small Ansible playbook to install the E-ink driver and the clock demo:&lt;/p&gt;
&lt;pre class="literal-block"&gt;- name: install required dependencies
  apt:
    name:
      - git
      - libfuse-dev
      - fonts-liberation
      - python-pil
    state: present
    update_cache: yes

- name: check if the epd-fuse service exists
  command: systemctl status epd-fuse.service
  check_mode: no
  failed_when: False
  changed_when: False
  register: epd_fuse_service

- name: clone the embeddedartists gratis repository
  git:
    repo: https://github.com/embeddedartists/gratis.git
    version: 9b7accc68db23865935b0d90c77a33055483b290
    dest: /home/pi/gratis

- name: build the EPD driver and install the epd-fuse service
  shell: &amp;gt;
    COG_VERSION=V2 make rpi-epd_fuse &amp;amp;&amp;amp;
    COG_VERSION=V2 make rpi-install
  args:
    chdir: /home/pi/gratis/PlatformWithOS
  when: epd_fuse_service.rc != 0

- name: ensure the epd-fuse service is enabled and started
  service:
    name: epd-fuse
    state: started
    enabled: yes

- name: install the epd-clock service
  copy:
    src: epd-clock.service
    dest: /etc/systemd/system/epd-clock.service
    owner: root
    group: root
    mode: 0644

- name: start and enable epd-clock service
  systemd:
    name: epd-clock.service
    daemon_reload: yes
    state: started
    enabled: yes&lt;/pre&gt;
&lt;p&gt;Note that commit &lt;a class="reference external" href="https://github.com/embeddedartists/gratis/commit/282e88f8f642d8086d779c462d248063770482e3"&gt;282e88f&lt;/a&gt; in embeddedartists/gratis repository added support
for the RaspberryPi 3, but broke the PI Zero W.
You currently have to use the commit 9b7accc68 if you have a PI Zero W.&lt;/p&gt;
&lt;p&gt;To run the playbook, clone the repository &lt;a class="reference external" href="https://github.com/beenje/legomac"&gt;https://github.com/beenje/legomac&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;$ git clone https://github.com/beenje/legomac.git
$ cd legomac
$ ansible-playbook -i hosts -k epd-demo.yml&lt;/pre&gt;
&lt;p&gt;That's it!&lt;/p&gt;
&lt;p&gt;Of course don't forget to change the default password on your Pi.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="one-more-thing"&gt;
&lt;h2&gt;One more thing&lt;/h2&gt;
&lt;p&gt;There isn't much Python in this article but the Pi is running some
Python code.
I couldn't resist putting a &lt;a class="reference external" href="https://talkpython.fm"&gt;Talk Python To Me&lt;/a&gt;
sticker on the back :-)
It's really a great podcast and you should definitevely give it a try if
you haven't yet.
Thanks again to @mkennedy for the stickers!&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://beenje.github.io/blog/images/legomac/talkpythontome.jpg"&gt;&lt;img alt="/images/legomac/talkpythontome.thumbnail.jpg" src="http://beenje.github.io/blog/images/legomac/talkpythontome.thumbnail.jpg"&gt;&lt;/a&gt;
&lt;p&gt;Below are a few pictures. You can see more on &lt;a class="reference external" href="https://flic.kr/s/aHskVAadfo"&gt;flickr&lt;/a&gt;.&lt;/p&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;span class="docutils literal"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;, line 246)&lt;/p&gt;
&lt;p&gt;Unknown directive type "slides".&lt;/p&gt;
&lt;pre class="literal-block"&gt;.. slides::

    /images/legomac/legomac.jpg
    /images/legomac/legomac_front_close.jpg
    /images/legomac/talkpythontome.jpg
    /images/legomac/drilling_left.jpg
    /images/legomac/drilling_right.jpg
    /images/legomac/ribbon_cable.jpg
    /images/legomac/display_front.jpg
    /images/legomac/button_front.jpg
    /images/legomac/button_top.jpg

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="next"&gt;
&lt;h2&gt;Next&lt;/h2&gt;
&lt;p&gt;I didn't build this LEGO Macintosh to use it as a simple clock :-)
I have a few ideas. I'll start with a small web server so that I can receive and display messages.
That will be the subject of another &lt;a class="reference external" href="http://beenje.github.io/blog/posts/experimenting-with-asyncio-on-a-raspberry-pi"&gt;blog post&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>lego</category><category>Mac</category><category>pi</category><category>python</category><guid>http://beenje.github.io/blog/posts/my-lego-macintosh-classic-with-raspberry-pi-and-e-paper-display/</guid><pubDate>Tue, 23 May 2017 20:39:12 GMT</pubDate></item><item><title>OpenVPN source based routing</title><link>http://beenje.github.io/blog/posts/openvpn-source-based-routing/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;I already spoke about installing OpenVPN on a Raspberry Pi in another blog
&lt;a class="reference external" href="http://beenje.github.io/blog/posts/installing-openvpn-on-a-raspberry-pi-with-ansible"&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I only connect to this VPN server to access content that requires a french IP address.
I use OpenVPN Connect App on my iPad and &lt;a class="reference external" href="https://tunnelblick.net"&gt;Tunnelblick&lt;/a&gt;
on my mac.
It works nicely but how to use this VPN on my Apple TV 4?
There is no VPN client available...&lt;/p&gt;
&lt;p&gt;End of last year I finally received my &lt;a class="reference external" href="https://omnia.turris.cz/en/"&gt;Turris Omnia&lt;/a&gt; that I supported on Indiegogo.
It's a nice router running a free operating system based on
OpenWrt with automatic updates.
If you haven't heard about it, you should check it out.&lt;/p&gt;
&lt;div class="section" id="configuring-openvpn-client-on-openwrt"&gt;
&lt;h2&gt;Configuring OpenVPN client on OpenWrt&lt;/h2&gt;
&lt;p&gt;Installing an OpenVPN client on OpenWrt is not very difficult.
Here is a quick summary.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;Install &lt;cite&gt;openvpn-openssl&lt;/cite&gt; package (via the
webinterface or the command line)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I already have a custom client config that I generated with Ansible in
this &lt;a class="reference external" href="http://beenje.github.io/blog/posts/installing-openvpn-on-a-raspberry-pi-with-ansible"&gt;post&lt;/a&gt;.
To use this config, create the file &lt;cite&gt;/etc/config/openvpn&lt;/cite&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# cat /etc/config/openvpn
package openvpn

config openvpn myvpn
        # Set to 1 to enable this instance:
        option enabled 1
        # Include OpenVPN configuration
        option config /etc/openvpn/myclientconfig.ovpn&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add a new interface in &lt;cite&gt;/etc/config/network&lt;/cite&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;config interface 'myvpn'
       option proto 'none'
       option ifname 'tun0'&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add a new zone to &lt;cite&gt;/etc/config/firewall&lt;/cite&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;config zone
        option forward 'REJECT'
        option output 'ACCEPT'
        option name 'VPN_FW'
        option input 'REJECT'
        option masq '1'
        option network 'myvpn'
        option mtu_fix '1'

config forwarding
        option dest 'VPN_FW'
        option src 'lan'&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An easy way to configure DNS servers is to add fixed DNS for the WAN interface of the router.
To use Google DNS, add the following two lines to the wan interface in &lt;cite&gt;/etc/config/network&lt;/cite&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# diff -u network.save network
@@ -20,6 +20,8 @@
 config interface 'wan'
         option ifname 'eth1'
         option proto 'dhcp'
+        option peerdns '0'
+        option dns '8.8.8.8 8.8.4.4'&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you run &lt;cite&gt;/etc/init.d/openvpn start&lt;/cite&gt; with this config, you should connect successfully!
All the traffic will go via the VPN. That's nice but it's not what I want.
I only want my Apple TV traffic to go via the VPN. How to achieve that?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="source-based-routing"&gt;
&lt;h2&gt;Source based routing&lt;/h2&gt;
&lt;p&gt;I quickly found this &lt;a class="reference external" href="https://wiki.openwrt.org/doc/networking/routing"&gt;wiki page&lt;/a&gt; to implement source
based routing. Exactly what I want. What took me some time to realize is
that before to do that I had to ignore the routes pushed by the server.&lt;/p&gt;
&lt;p&gt;With my configuration, when the client connects, the server pushes some
routes among which a default route that makes all the traffic go via the
VPN:&lt;/p&gt;
&lt;pre class="literal-block"&gt;Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         10.8.0.21       128.0.0.0       UG    0      0        0 tun0
...&lt;/pre&gt;
&lt;p&gt;Ignoring the routes pushed by the server can be done with the &lt;cite&gt;--route-noexec&lt;/cite&gt; option.
I tried to add &lt;cite&gt;option route_noexec 1&lt;/cite&gt; to my &lt;cite&gt;/etc/config/openvpn&lt;/cite&gt; file
but it had no effect. It looks like that when using a custom config, you
can't add other options there. You have to set everything in the custom
config. I added &lt;cite&gt;route-noexec&lt;/cite&gt; to  my &lt;cite&gt;/etc/openvpn/myclientconfig.ovpn&lt;/cite&gt; file and it worked!
No more route added. No traffic sent via the VPN.&lt;/p&gt;
&lt;p&gt;We can now apply the changes described in the &lt;a class="reference external" href="https://wiki.openwrt.org/doc/networking/routing"&gt;Routing wiki page&lt;/a&gt;.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;Install the &lt;cite&gt;ip&lt;/cite&gt; package&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add the &lt;cite&gt;10 vpn&lt;/cite&gt; line to &lt;cite&gt;/etc/iproute2/rt_tables&lt;/cite&gt; so that it looks like
this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# cat /etc/iproute2/rt_tables
#
# reserved values
#
255  local
254  main
253  default
10   vpn
0    unspec
#
# local
#
#1  inr.ruhep&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We now need to add a new rule and route when starting the client.
We can do so using the openvpn &lt;cite&gt;up&lt;/cite&gt; command. Create the &lt;cite&gt;/etc/openvpn/upvpn&lt;/cite&gt; script:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# cat /etc/openvpn/upvpn
#!/bin/sh

client=192.168.75.20

tun_dev=$1
tun_mtu=$2
link_mtu=$3
ifconfig_local_ip=$4
ifconfig_remote_ip=$5

echo "Routing client $client traffic through VPN"
ip rule add from $client priority 10 table vpn
ip route add $client dev $tun_dev table vpn
ip route add default via $ifconfig_remote_ip dev $tun_dev table vpn
ip route flush cache&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Create the &lt;cite&gt;/etc/openvpn/downvpn&lt;/cite&gt; script to properly remove the rule and route:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# cat /etc/openvpn/downvpn
#!/bin/sh

client=192.168.75.20

tun_dev=$1
tun_mtu=$2
link_mtu=$3
ifconfig_local_ip=$4
ifconfig_remote_ip=$5

echo "Delete client $client traffic routing through VPN"
ip rule del from $client priority 10 table vpn
ip route del $client dev $tun_dev table vpn
ip route del default via $ifconfig_remote_ip dev $tun_dev table vpn
ip route flush cache&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We now have to add those scripts to the client config.
Here is everything I added to my &lt;cite&gt;/etc/openvpn/myclientconfig.ovpn&lt;/cite&gt; file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;# Don't add or remove routes automatically
# Source based routing for specific client added in up script
route-noexec
# script-security 2 needed to run up and down scripts
script-security 2
# Script to run after successful TUN/TAP device open
up /etc/openvpn/upvpn
# Call down script before to close TUN to properly remove the routing
down-pre
down /etc/openvpn/downvpn&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice that the machine IP address that we want to route via the VPN is
hard-coded in the the upvpn and downvpn scripts.
This IP shall be fixed. You can easily do that by associating it to
the required MAC address in the DHCP settings.&lt;/p&gt;
&lt;p&gt;The tunnel remote IP is automatically passed in parameter to the up and
down scripts by openvpn.&lt;/p&gt;
&lt;p&gt;If we run &lt;cite&gt;/etc/init.d/openvpn start&lt;/cite&gt; with this config, only the traffic
from the 192.168.75.20 IP address will go via the VPN!&lt;/p&gt;
&lt;p&gt;Run &lt;cite&gt;/etc/init.d/openvpn stop&lt;/cite&gt; to close the tunnel.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is a nice way to route traffic through a VPN based on the source IP
address.&lt;/p&gt;
&lt;p&gt;You can of course use the router webinterface to stop and start openvpn.
In &lt;a class="reference external" href="http://beenje.github.io/blog/posts/home-assistant-on-turris-omnia-via-lxc-container"&gt;another post&lt;/a&gt;,
I'll talk about an even more user friendly way to control it.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>AppleTV</category><category>OpenWrt</category><category>pi</category><category>VPN</category><guid>http://beenje.github.io/blog/posts/openvpn-source-based-routing/</guid><pubDate>Fri, 20 Jan 2017 20:46:16 GMT</pubDate></item><item><title>Installing OpenVPN on a Raspberry Pi with Ansible</title><link>http://beenje.github.io/blog/posts/installing-openvpn-on-a-raspberry-pi-with-ansible/</link><dc:creator>Benjamin Bertrand</dc:creator><description>&lt;div&gt;&lt;p&gt;I have to confess that I initially decided to install a VPN,
not to secure my connection when using a free Wireless Acces Point in an
airport or hotel, but to watch Netflix :-)&lt;/p&gt;
&lt;p&gt;I had a VPS in France where I installed sniproxy to access Netflix.
Not that I find the french catalogue so great, but as a French guy living
in Sweden, it was a good way for my kids to watch some french programs.
But Netflix started to block VPS providers...&lt;/p&gt;
&lt;p&gt;I have a brother in France who has a Fiber Optic Internet access.
That was a good opportunity to setup a private VPN and I bought him a Raspberry Pi.&lt;/p&gt;
&lt;p&gt;There are many resources on the web about &lt;a class="reference external" href="https://openvpn.net/index.php/open-source/documentation/howto.html"&gt;OpenVPN&lt;/a&gt;.
A paper worth mentioning is: &lt;a class="reference external" href="https://www.sans.org/reading-room/whitepapers/networkdevs/soho-remote-access-vpn-easy-pie-raspberry-pi-34427"&gt;SOHO Remote Access VPN. Easy as Pie, Raspberry Pi...&lt;/a&gt;
It's from end of 2013 and describes Esay-RSA 2.0 (that used to be installed with
OpenVPN), but it's still an interesting read.&lt;/p&gt;
&lt;p&gt;Anyway, most resources describe all the commands to run.
I don't really like installing softwares by running a bunch of commands. Propably due
to my professional experience, I like things to be reproducible.
That's why I love to automate things. I wrote a lot of shell scripts over
the years. About two years ago, I discovered &lt;a class="reference external" href="http://docs.ansible.com/ansible/index.html"&gt;Ansible&lt;/a&gt; and it quickly became my
favorite tool to deploy software.&lt;/p&gt;
&lt;p&gt;So let's write a small Ansible playbook to install OpenVPN on a Raspberry Pi.&lt;/p&gt;
&lt;p&gt;First the firewall configuration. I like to use &lt;a class="reference external" href="https://help.ubuntu.com/community/UFW"&gt;ufw&lt;/a&gt; which is quite easy to
setup:&lt;/p&gt;
&lt;pre class="literal-block"&gt;- name: install dependencies
  apt: name=ufw state=present update_cache=yes cache_valid_time=3600

- name: update ufw default forward policy
  lineinfile: dest=/etc/default/ufw regexp=^DEFAULT_FORWARD_POLICY line=DEFAULT_FORWARD_POLICY="ACCEPT"
  notify: reload ufw

- name: enable ufw ip forward
  lineinfile: dest=/etc/ufw/sysctl.conf regexp=^net/ipv4/ip_forward line=net/ipv4/ip_forward=1
  notify: reload ufw

- name: add NAT rules to ufw
  blockinfile:
    dest: /etc/ufw/before.rules
    insertbefore: BOF
    block: |
      # Nat table
      *nat
      :POSTROUTING ACCEPT [0:0]

      # Nat rules
      -F
      -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j SNAT --to-source {{ansible_eth0.ipv4.address}}

      # don't delete the 'COMMIT' line or these nat rules won't be processed
      COMMIT
  notify: reload ufw

- name: allow ssh
  ufw: rule=limit port=ssh proto=tcp

- name: allow openvpn
  ufw: rule=allow port={{openvpn_port}} proto={{openvpn_protocol}}

- name: enable ufw
  ufw: logging=on state=enabled&lt;/pre&gt;
&lt;p&gt;This enables IP forwarding, adds the required NAT rules and allows ssh and
openvpn.&lt;/p&gt;
&lt;p&gt;The rest of the playbook installs OpenVPN and generates all the keys automatically,
except the Diffie-Hellman one that should be generated locally.
This is just because it takes for ever on the Pi :-)&lt;/p&gt;
&lt;pre class="literal-block"&gt;- name: install openvpn
  apt: name=openvpn state=present

- name: create /etc/openvpn
  file: path=/etc/openvpn state=directory mode=0755 owner=root group=root

- name: create /etc/openvpn/keys
  file: path=/etc/openvpn/keys state=directory mode=0700 owner=root group=root

- name: create clientside and serverside directories
  file: path="{{item}}" state=directory mode=0755
  with_items:
      - "{{clientside}}/keys"
      - "{{serverside}}"
  become: true
  become_user: "{{user}}"

- name: create openvpn base client.conf
  template: src=client.conf.j2 dest={{clientside}}/client.conf owner=root group=root mode=0644

- name: download EasyRSA
  get_url: url={{easyrsa_url}} dest=/home/{{user}}/openvpn
  become: true
  become_user: "{{user}}"

- name: create scripts
  template: src={{item}}.j2 dest=/home/{{user}}/openvpn/{{item}} owner=root group=root mode=0755
  with_items:
    - create_serverside
    - create_clientside
  tags: client

- name: run serverside script
  command: ./create_serverside
  args:
    chdir: /home/{{user}}/openvpn
    creates: "{{easyrsa_server}}/ta.key"
  become: true
  become_user: "{{user}}"

- name: run clientside script
  command: ./create_clientside {{item}}
  args:
    chdir: /home/{{user}}/openvpn
    creates: "{{clientside}}/files/{{item}}.ovpn"
  become: true
  become_user: "{{user}}"
  with_items: "{{openvpn_clients}}"
  tags: client

- name: install all server keys
  command: install -o root -g root -m 600 {{item.name}} /etc/openvpn/keys/
  args:
    chdir: "{{item.path}}"
    creates: /etc/openvpn/keys/{{item.name}}
  with_items:
    - { name: 'ca.crt', path: "{{easyrsa_server}}/pki" }
    - { name: '{{ansible_hostname}}.crt', path: "{{easyrsa_server}}/pki/issued" }
    - { name: '{{ansible_hostname}}.key', path: "{{easyrsa_server}}/pki/private" }
    - { name: 'ta.key', path: "{{easyrsa_server}}" }

- name: copy Diffie-Hellman key
  copy: src="{{openvpn_dh}}" dest=/etc/openvpn/keys/dh.pem owner=root group=root mode=0600

- name: create openvpn server.conf
  template: src=server.conf.j2 dest=/etc/openvpn/server.conf owner=root group=root mode=0644
  notify: restart openvpn

- name: start openvpn
  service: name=openvpn state=started&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;create_clientside&lt;/em&gt; script generates all the required client keys and creates an ovpn file
that includes them.  It makes it very easy to install on any device: just one file to
drop.&lt;/p&gt;
&lt;p&gt;One thing I stumbled upon is the &lt;em&gt;ns-cert-type server&lt;/em&gt; option that I
initially used in the server configuration. This prevented the client to
connect. As explained &lt;a class="reference external" href="https://community.openvpn.net/openvpn/wiki/EasyRSA3-OpenVPN-Howto"&gt;here&lt;/a&gt;,
this option is a deprecated "Netscape" cert attribute. It's not enabled by
default with Easy-RSA 3.&lt;/p&gt;
&lt;p&gt;Fortunately, the mentioned &lt;a class="reference external" href="https://community.openvpn.net/openvpn/wiki/EasyRSA3-OpenVPN-Howto"&gt;howto&lt;/a&gt; and
the &lt;a class="reference external" href="https://github.com/OpenVPN/easy-rsa"&gt;Easy-RSA github&lt;/a&gt; page are good references
for Easy-RSA 3.&lt;/p&gt;
&lt;p&gt;One important thing to note is that I create all the keys with no password.
That's obviously not the most secure and recommended way.
Anyone accessing the CA could sign new requests. But it can be stored offline on an USB stick.
I actually think that for my use case it's not even worth keeping the CA.
Sure it means I can't easily add a new client or revoke a certificate.
But with the playbook, it's super easy to throw all the keys and regenerate everything.
That forces to replace all clients configuration but with 2 or 3
clients, this is not a problem.&lt;/p&gt;
&lt;p&gt;For sure don't leave all the generated keys on the Pi!
After copying the clients ovpn files, remove the /home/pi/openvpn
directory (save it somewhere safe if you want to add new clients or revoke
a certificate without regenerating everything).&lt;/p&gt;
&lt;p&gt;The full playbook can be found on &lt;a class="reference external" href="https://github.com/beenje/pi_openvpn"&gt;github&lt;/a&gt;.
The README includes some quick instructions.&lt;/p&gt;
&lt;p&gt;I now have a private VPN in France and one at home that I can use to
securely access my NAS from anywhere!&lt;/p&gt;&lt;/div&gt;</description><category>Ansible</category><category>pi</category><category>VPN</category><guid>http://beenje.github.io/blog/posts/installing-openvpn-on-a-raspberry-pi-with-ansible/</guid><pubDate>Mon, 18 Jul 2016 20:26:28 GMT</pubDate></item></channel></rss>